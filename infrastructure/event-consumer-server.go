package infrastructure

import (
	"fmt"
	"io"

	"github.com/verbruggenjesse/grpc-consumer/domain"
	"github.com/verbruggenjesse/grpc-consumer/domain/abstract"
	"github.com/verbruggenjesse/grpc-consumer/protos/eventstore"
)

// EventConsumerServer is an implementation of the ConsumerServer interface generated by protobuf
type EventConsumerServer struct {
	eventstore.UnimplementedConsumerServer
	subscriber *RedisSubscriber
	logger     *Logger
}

// NewEventConsumerServer is the constructor for an EventConsumerServer
func NewEventConsumerServer(subscriber *RedisSubscriber, logger *Logger) *EventConsumerServer {
	return &EventConsumerServer{
		subscriber: subscriber,
		logger:     logger,
	}
}

func (e *EventConsumerServer) Read(stream eventstore.Consumer_ReadServer) error {
	e.logger.Info("client connected")
	client := NewEventClient(e.subscriber)

	subscriptions := make(chan abstract.ISubscription)

	go func() {
		for {
			eventRange, err := stream.Recv()
			if err != nil {
				*client.ErrorChan() <- err
			}

			subscription := domain.NewEventSubscription(eventRange.GetKey(), eventRange.GetFrom(), eventRange.GetTo(), eventRange.GetCount(), eventRange.GetIncludeMetadata())
			subscriptions <- subscription
		}
	}()

	for {
		select {
		case subscription := <-subscriptions:
			e.logger.Info(fmt.Sprintf("request received: %v", subscription))
			client.Subscribe(subscription)
			continue
		case event := <-*client.EventChan():
			e.logger.Info(fmt.Sprintf("sending event: %v", event))
			stream.Send(event)
			continue
		case err := <-*client.ErrorChan():
			if err == io.EOF {
				e.logger.Info("client disconnecting")
				return nil
			}
			if err != nil {
				e.logger.Error(fmt.Sprintf("connection closed unexpectedly: %v", err))
				return err
			}
			continue
		default:
			continue
		}
	}
}
